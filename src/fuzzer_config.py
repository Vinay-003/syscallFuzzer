#!/usr/bin/env python3
"""
fuzzer_brain.py - Enhanced Production Version

Orchestrates syscall fuzzing in QEMU Alpine VM with improved:
- Better crash detection and logging
- Cleaner code structure
- Performance optimizations
- Enhanced error handling
"""

import subprocess
import time
import os
import random
import re
import json
import signal
import sys
from datetime import datetime
from pathlib import Path

# Import configuration
from fuzzer_brain import SYSCALL_SPECS, SYSCALL_SEQUENCES, TYPE_GENERATORS

# ============================================================================
# CONFIGURATION
# ============================================================================

class Config:
    """Central configuration for the fuzzer"""
    # VM Settings
    VM_DISK_IMAGE = "../alpine.qcow2"
    VM_RAM = "1G"
    HOST_SSH_PORT = "10022"
    VM_USER = "root"
    VM_PASSWORD = "123"
    
    # Paths
    EXECUTOR_SOURCE = "executor.c"
    EXECUTOR_VM_PATH = "/root/executor"
    CRASHES_DIR = "crashes"
    
    # Timeouts (seconds)
    VM_BOOT_TIMEOUT = 60
    SSH_READY_TIMEOUT = 30
    SSH_COMMAND_TIMEOUT = 20
    VM_SHUTDOWN_TIMEOUT = 30
    
    # Fuzzing behavior
    SEQUENCE_PROBABILITY = 0.5  # 50% chance to run sequence vs single syscall
    ITERATION_DELAY = 0.1  # seconds between iterations
    
    # QEMU command
    @staticmethod
    def get_qemu_command():
        return [
            "qemu-system-x86_64",
            "-m", Config.VM_RAM,
            "-hda", Config.VM_DISK_IMAGE,
            "-nographic",
            "-netdev", f"user,id=net0,hostfwd=tcp::{Config.HOST_SSH_PORT}-:22",
            "-device", "e1000,netdev=net0",
            "-enable-kvm"
        ]


# ============================================================================
# CRASH LOGGING
# ============================================================================

class CrashLogger:
    """Handles crash detection and artifact collection"""
    
    def __init__(self, crashes_dir):
        self.crashes_dir = Path(crashes_dir)
        self.crashes_dir.mkdir(exist_ok=True)
    
    def log_crash(self, reproducer_commands, crash_context=None):
        """
        Save comprehensive crash information
        
        Args:
            reproducer_commands: Command(s) that caused the crash
            crash_context: Additional context (dict with metadata)
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        crash_dir = self.crashes_dir / f"crash_{timestamp}"
        crash_dir.mkdir(exist_ok=True)
        
        print("\n" + "!" * 70)
        print(f"{'CRASH DETECTED':^70}")
        print(f"{'Saving to: ' + str(crash_dir):^70}")
        print("!" * 70)
        
        # Save reproducer script
        reproducer_file = crash_dir / "reproducer.sh"
        with open(reproducer_file, "w") as f:
            f.write("#!/bin/bash\n")
            f.write("# Crash reproducer generated by syscall fuzzer\n")
            f.write(f"# Timestamp: {timestamp}\n\n")
            
            if isinstance(reproducer_commands, (list, tuple)):
                for cmd in reproducer_commands:
                    f.write(f"{cmd}\n")
            else:
                f.write(f"{reproducer_commands}\n")
        
        reproducer_file.chmod(0o755)
        
        # Save metadata
        metadata = {
            "timestamp": timestamp,
            "commands": reproducer_commands if isinstance(reproducer_commands, list) else [reproducer_commands],
            "crash_context": crash_context or {}
        }
        
        with open(crash_dir / "metadata.json", "w") as f:
            json.dump(metadata, f, indent=2)
        
        # Save summary
        with open(crash_dir / "crash_summary.txt", "w") as f:
            f.write("=== Syscall Fuzzer Crash Report ===\n")
            f.write(f"Timestamp: {timestamp}\n")
            f.write(f"Crash Directory: {crash_dir}\n\n")
            
            f.write("--- Reproducer Commands ---\n")
            if isinstance(reproducer_commands, (list, tuple)):
                for i, cmd in enumerate(reproducer_commands, 1):
                    f.write(f"{i}. {cmd}\n")
            else:
                f.write(f"{reproducer_commands}\n")
            
            if crash_context:
                f.write("\n--- Additional Context ---\n")
                for key, value in crash_context.items():
                    f.write(f"{key}: {value}\n")
        
        print(f"[+] Crash artifacts saved to: {crash_dir}")
        return crash_dir
    
    def collect_vm_logs(self, ssh_runner, crash_dir):
        """Collect dmesg and other logs from VM"""
        print("[*] Collecting VM logs...")
        
        # # Try to get dmesg
        # try:
        #     result = ssh_runner.run_command(
        #         "dmesg -T > /tmp/crash_dmesg.txt 2>&1",
        #         suppress_errors=True,
        #         timeout=15
        #     )
            
        #     if result:
        #         ssh_runner.fetch_file(
        #             "/tmp/crash_dmesg.txt",
        #             crash_dir / "dmesg.txt"
        #         )
        # except Exception as e:
        #     print(f"[!] Failed to collect dmesg: {e}")
        
        # # Try to get kernel logs
        # try:
        #     ssh_runner.fetch_file(
        #         "/var/log/messages",
        #         crash_dir / "kernel_messages.log"
        #     )
        # except Exception:
        #     pass
        
        print("[+] Log collection complete")


# ============================================================================
# SSH OPERATIONS
# ============================================================================

class SSHRunner:
    """Handles SSH communication with the VM"""
    
    def __init__(self, host="localhost", port=None, user=None, password=None):
        self.host = host
        self.port = port or Config.HOST_SSH_PORT
        self.user = user or Config.VM_USER
        self.password = password or Config.VM_PASSWORD
        self.ssh_base_opts = [
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=/dev/null",
            "-o", "ConnectTimeout=10",
            "-o", "LogLevel=ERROR"
        ]
    
    def check_ssh_ready(self):
        """Check if SSH port is accepting connections"""
        try:
            result = subprocess.run(
                ["nc", "-z", self.host, self.port],
                timeout=2,
                capture_output=True
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            return False
    
    def run_command(self, command, suppress_errors=False, timeout=None):
        """
        Execute command in VM via SSH
        
        Returns:
            CompletedProcess on success, None on failure
        """
        timeout = timeout or Config.SSH_COMMAND_TIMEOUT
        
        ssh_cmd = [
            "sshpass", "-p", self.password,
            "ssh", f"{self.user}@{self.host}",
            "-p", self.port
        ] + self.ssh_base_opts + [command]
        
        try:
            if not suppress_errors:
                print(f"[VM] {command}")
            
            result = subprocess.run(
                ssh_cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                if not suppress_errors and result.stdout.strip():
                    print(f"[VM OUTPUT] {result.stdout.strip()}")
                return result
            else:
                if not suppress_errors:
                    print(f"[!] Command failed (exit {result.returncode})")
                    if result.stderr.strip():
                        print(f"[VM ERROR] {result.stderr.strip()}")
                return None
                
        except subprocess.TimeoutExpired:
            if not suppress_errors:
                print(f"[!] Command timed out after {timeout}s")
            return None
        except Exception as e:
            if not suppress_errors:
                print(f"[!] SSH error: {e}")
            return None
    
    def transfer_file(self, local_path, remote_path):
        """Copy file from host to VM"""
        print(f"[*] Transfer: {local_path} → VM:{remote_path}")
        
        scp_cmd = [
            "sshpass", "-p", self.password,
            "scp", "-P", self.port
        ] + self.ssh_base_opts + [
            local_path,
            f"{self.user}@{self.host}:{remote_path}"
        ]
        
        try:
            subprocess.run(scp_cmd, check=True, capture_output=True, timeout=30)
            print("[+] Transfer successful")
            return True
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            print(f"[!] Transfer failed: {e}")
            return False
    
    def fetch_file(self, remote_path, local_path):
        """Copy file from VM to host"""
        print(f"[*] Fetch: VM:{remote_path} → {local_path}")
        
        scp_cmd = [
            "sshpass", "-p", self.password,
            "scp", "-P", self.port
        ] + self.ssh_base_opts + [
            f"{self.user}@{self.host}:{remote_path}",
            str(local_path)
        ]
        
        try:
            subprocess.run(scp_cmd, check=True, capture_output=True, timeout=30)
            print("[+] Fetch successful")
            return True
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            print(f"[!] Fetch failed: {e}")
            return False


# ============================================================================
# VM MANAGEMENT
# ============================================================================

class VMManager:
    """Manages QEMU VM lifecycle"""
    
    def __init__(self, ssh_runner):
        self.ssh_runner = ssh_runner
        self.vm_process = None
    
    def start_vm(self):
        """Start VM and wait for SSH readiness"""
        print("[*] Starting VM...")
        
        try:
            self.vm_process = subprocess.Popen(
                Config.get_qemu_command(),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        except Exception as e:
            print(f"[!] Failed to start VM: {e}")
            return False
        
        print(f"[+] VM started (PID: {self.vm_process.pid})")
        
        # Wait for SSH port
        print("[*] Waiting for SSH port...")
        start_time = time.time()
        
        while time.time() - start_time < Config.VM_BOOT_TIMEOUT:
            if self.ssh_runner.check_ssh_ready():
                print("[+] SSH port open")
                time.sleep(5)  # Let SSH service fully initialize
                
                # Verify SSH responsiveness
                if self._verify_ssh_responsive():
                    print("[+] VM ready")
                    return True
                
            time.sleep(1)
        
        print("[!] VM boot timeout")
        self.terminate_vm()
        return False
    
    def _verify_ssh_responsive(self):
        """Verify SSH is actually responsive"""
        print("[*] Verifying SSH responsiveness...")
        
        start_time = time.time()
        while time.time() - start_time < Config.SSH_READY_TIMEOUT:
            result = self.ssh_runner.run_command(
                "echo SSH_OK",
                suppress_errors=True
            )
            
            if result and "SSH_OK" in (result.stdout or ""):
                return True
            
            time.sleep(2)
        
        return False
    
    def shutdown_vm(self, force=False):
        """Gracefully shutdown VM"""
        if not self.vm_process:
            return
        
        if force:
            print("[*] Force terminating VM...")
            self.vm_process.terminate()
        else:
            print("[*] Shutting down VM gracefully...")
            self.ssh_runner.run_command("poweroff", suppress_errors=True, timeout=10)
            
            try:
                self.vm_process.wait(timeout=Config.VM_SHUTDOWN_TIMEOUT)
            except subprocess.TimeoutExpired:
                print("[!] Graceful shutdown timeout, forcing...")
                self.vm_process.terminate()
        
        self.vm_process = None
        print("[+] VM stopped")
    
    def terminate_vm(self):
        """Immediately terminate VM"""
        self.shutdown_vm(force=True)
    
    def is_running(self):
        """Check if VM is still running"""
        if not self.vm_process:
            return False
        return self.vm_process.poll() is None


# ============================================================================
# FUZZING ENGINE
# ============================================================================

class FuzzingEngine:
    """Core fuzzing logic"""
    
    # Regex to parse executor output
    # RE_SYSCALL_RET = re.compile(r"syscall\((\d+)\)\s*=\s*(-?\d+)")
    
    def __init__(self, ssh_runner, crash_logger):
        self.ssh_runner = ssh_runner
        self.crash_logger = crash_logger
        self.iteration = 0
        # --- ADD THIS BLOCK ---
        self.corpus_dir = Path("corpus")
        self.corpus_dir.mkdir(exist_ok=True)
        self.coverage = set()
        # --- END ADD ---
        self.stats = {
            "total_syscalls": 0,
            "total_sequences": 0,
            "crashes": 0,
            "new_coverage": 0  # <-- Add this line
        }
        self.resource_pool = {
            "fd": [],
        }
        print("[*] Fuzzing engine initialized with an empty resource pool.")
    
    # Regex to parse executor output, now with an optional coverage group
    RE_SYSCALL_RET = re.compile(r"syscall\((\d+)\)\s*=\s*(-?\d+).*coverage=(\d+)")

    def parse_executor_output(self, stdout):
        """Extract syscall return and coverage values from executor output"""
        if not stdout:
            return None, None
        
        match = self.RE_SYSCALL_RET.search(stdout)
        if match:
            try:
                ret_val = int(match.group(2))
                coverage = int(match.group(3))
                return ret_val, coverage
            except (ValueError, IndexError):
                return None, None
        return None, None
    
    def resolve_argument(self, arg_spec, env):
        """
        Resolve argument specification to concrete value
        
        Args:
            arg_spec: Argument specification (string, dict, or literal)
            env: Environment dict with stored results
        
        Returns:
            String representation of the argument value
        """
        # Handle literal value from sequence definition (e.g., {'literal': 123})
        if isinstance(arg_spec, dict) and "literal" in arg_spec:
            return str(arg_spec["literal"])
        
        # Handle environment variable reference (e.g., {'value': 'fd1'})
        if isinstance(arg_spec, dict) and "value" in arg_spec:
            var_name = arg_spec["value"]
            return str(env.get(var_name, 0))
        
        # Handle type generator
        if isinstance(arg_spec, str):
            # --- LOGIC TO USE THE POOL STARTS HERE ---
            if arg_spec == "valid_fd":
                if self.resource_pool["fd"]:
                    # We have valid FDs, let's use one!
                    chosen_fd = random.choice(self.resource_pool["fd"])
                    print(f"[*] Using valid resource from pool: fd={chosen_fd}")
                    return str(chosen_fd)
                else:
                    # Pool is empty, fall back to the original random generator.
                    # This keeps the fuzzer running even before it finds a valid FD.
                    return str(TYPE_GENERATORS['fd']())
            # --- LOGIC TO USE THE POOL ENDS HERE ---

            # Check if it's an env variable
            if arg_spec in env:
                return str(env[arg_spec])
            
            # Check if it's a generator type
            generator = TYPE_GENERATORS.get(arg_spec)
            if generator:
                try:
                    return str(generator())
                except Exception:
                    return "0"
            
            # Return as-is (literal string)
            return arg_spec
        
        # Return literal value
        return str(arg_spec)
    
    def generate_random_syscall(self):
        """Generate a random syscall with arguments"""
        syscall_name = random.choice(list(SYSCALL_SPECS.keys()))
        arg_types = SYSCALL_SPECS[syscall_name]
        args = [self.resolve_argument(arg_type, {}) for arg_type in arg_types]
        return syscall_name, args
    
    def execute_syscall(self, syscall_name, args):
        """
        Execute a single syscall and return result
        
        Returns:
            (success: bool, (return_value: int or None, coverage: int or None))
        """
        command = f"{Config.EXECUTOR_VM_PATH} {syscall_name} {' '.join(args)}"
        result = self.ssh_runner.run_command(command)
        
        if result is None:
            # Command failed - potential crash
            return False, (None, None)
        
        ret_val, coverage = self.parse_executor_output(result.stdout)
        return True, (ret_val, coverage)
        
        ret_val = self.parse_executor_output(result.stdout)
        return True, ret_val
    
    def execute_sequence(self, sequence_name, steps):
        """
        Execute a sequence of syscalls with environment tracking
        
        Returns:
            (success: bool, commands_executed: list)
        """
        print(f"[*] Executing sequence: {sequence_name}")
        
        env = {}
        commands = []
        
        for step_num, step in enumerate(steps, 1):
            syscall_name = step.get("action") or step.get("name")
            arg_specs = step.get("args", [])
            
            # Resolve arguments
            args = [self.resolve_argument(spec, env) for spec in arg_specs]
            
            # Execute
            command = f"{Config.EXECUTOR_VM_PATH} {syscall_name} {' '.join(args)}"
            commands.append(command)
            
            print(f"  [{step_num}/{len(steps)}] {syscall_name}({', '.join(args)})")
            
            result = self.ssh_runner.run_command(command)
            
            if result is None:
                # Command failed - potential crash
                return False, commands
            
            # Store result in environment if requested
            ret_val = self.parse_executor_output(result.stdout)
            if step.get("result"):
                result_var = step["result"]
                env[result_var] = ret_val if ret_val is not None else 0
                print(f"    → {result_var} = {env[result_var]}")
        
        print(f"[+] Sequence '{sequence_name}' completed successfully")
        return True, commands
    
    def run_iteration(self):
        """Run a single fuzzing iteration"""
        self.iteration += 1
        print(f"\n{'=' * 70}")
        print(f"Iteration #{self.iteration}")
        print('=' * 70)
        
        # Decide: single syscall or sequence?
        # Note: We are only implementing coverage feedback for single syscalls for now.
        if random.random() < Config.SEQUENCE_PROBABILITY and SYSCALL_SEQUENCES:
            # Execute sequence (original logic)
            sequence_name, steps = random.choice(list(SYSCALL_SEQUENCES.items()))
            success, commands = self.execute_sequence(sequence_name, steps)
            
            self.stats["total_sequences"] += 1
            self.stats["total_syscalls"] += len(steps)
            
            if not success:
                # Crash detected
                self.stats["crashes"] += 1
                crash_dir = self.crash_logger.log_crash(
                    commands,
                    crash_context={
                        "type": "sequence",
                        "sequence_name": sequence_name,
                        "iteration": self.iteration,
                        "stats": self.stats.copy()
                    }
                )
                self.crash_logger.collect_vm_logs(self.ssh_runner, crash_dir)
                return False
        
        else:
            # Execute single syscall
            syscall_name, args = self.generate_random_syscall()
            command = f"{Config.EXECUTOR_VM_PATH} {syscall_name} {' '.join(args)}"
            print(f"[*] Testing: {syscall_name}({', '.join(args)})")
            
            success, (ret_val, coverage) = self.execute_syscall(syscall_name, args)
            
            self.stats["total_syscalls"] += 1
            
            # --- THIS IS THE CORE LOGIC FOR COVERAGE FEEDBACK ---
            if success and coverage is not None and coverage > 0:
                # We use a simple hash of the coverage value for this example.
                # In a real-world fuzzer, you'd process the full coverage buffer.
                if coverage not in self.coverage:
                    print(f"\n{'*' * 25} NEW COVERAGE FOUND! ({coverage}) {'*' * 25}")
                    self.coverage.add(coverage)
                    self.stats["new_coverage"] += 1
                    
                    # Save the input that generated new coverage to the corpus
                    corpus_filename = self.corpus_dir / f"coverage_{coverage}_iter_{self.iteration}"
                    with open(corpus_filename, "w") as f:
                        f.write(command)
                    print(f"[+] Saved new input to: {corpus_filename}")
            # --- END OF CORE LOGIC ---
            
            if not success:
                # Crash detected
                self.stats["crashes"] += 1
                crash_dir = self.crash_logger.log_crash(
                    command,
                    crash_context={
                        "type": "single",
                        "syscall": syscall_name,
                        "args": args,
                        "iteration": self.iteration,
                        "coverage": coverage,
                        "stats": self.stats.copy()
                    }
                )
                self.crash_logger.collect_vm_logs(self.ssh_runner, crash_dir)
                return False
            
            if ret_val is not None:
                print(f"[+] Return value: {ret_val} | Coverage: {coverage}")
        
        return True
    
    def run_session(self):
        """Run a complete fuzzing session until crash or interruption"""
        print("\n" + "#" * 70)
        print(f"{'FUZZING SESSION START':^70}")
        print("#" * 70)
        
        try:
            while True:
                success = self.run_iteration()
                
                if not success:
                    # Crash detected
                    return False
                
                time.sleep(Config.ITERATION_DELAY)
                
        except KeyboardInterrupt:
            print("\n[!] Session interrupted by user")
            return True
    
    def print_stats(self):
        """Print fuzzing statistics"""
        print("\n" + "=" * 70)
        print("FUZZING STATISTICS")
        print("=" * 70)
        print(f"Total Iterations:  {self.iteration}")
        print(f"Total Syscalls:    {self.stats['total_syscalls']}")
        print(f"Total Sequences:   {self.stats['total_sequences']}")
        print(f"Crashes Found:     {self.stats['crashes']}")
        print("=" * 70)


# ============================================================================
# SETUP AND INITIALIZATION
# ============================================================================

def setup_executor(ssh_runner):
    """Transfer and compile executor in VM"""
    print("\n" + "=" * 70)
    print("EXECUTOR SETUP")
    print("=" * 70)
    # --- ADD THIS BLOCK ---
    # Mount debugfs for KCOV if it's not already mounted
    print("[*] Mounting debugfs for KCOV...")
    ssh_runner.run_command(
        "mountpoint -q /sys/kernel/debug || mount -t debugfs none /sys/kernel/debug"
    )
    # --- END ADD ---

    # Transfer source
    if not ssh_runner.transfer_file(Config.EXECUTOR_SOURCE, "/root/executor.c"):
        print("[!] Failed to transfer executor source")
        return False
    
    # Install build tools
    print("[*] Installing build tools...")
    result = ssh_runner.run_command(
        "apk add --no-cache build-base",
        timeout=120
    )
    if not result:
        print("[!] Failed to install build tools")
        return False
    
    # Compile
    print("[*] Compiling executor...")
    result = ssh_runner.run_command(
        f"gcc -O2 /root/executor.c -o {Config.EXECUTOR_VM_PATH}",
        timeout=60
    )
    if not result:
        print("[!] Compilation failed")
        return False
    
    # Verify
    result = ssh_runner.run_command(
        f"test -x {Config.EXECUTOR_VM_PATH}",
        suppress_errors=True
    )
    if not result:
        print("[!] Executor not found after compilation")
        return False
    
    print("[+] Executor ready")
    return True


# ============================================================================
# MAIN ORCHESTRATION
# ============================================================================

def main():
    """Main fuzzer orchestration"""
    print("\n" + "#" * 70)
    print(f"{'SYSCALL FUZZER':^70}")
    print("#" * 70)
    
    # Initialize random seed
    seed = int(time.time() * 1000) & 0xFFFFFFFF
    random.seed(seed)
    print(f"[*] Random seed: {seed}")
    
    # Initialize components
    ssh_runner = SSHRunner()
    vm_manager = VMManager(ssh_runner)
    crash_logger = CrashLogger(Config.CRASHES_DIR)
    
    # Initial setup
    print("\n[*] Performing initial setup...")
    if not vm_manager.start_vm():
        print("[!] Initial VM startup failed")
        return 1
    
    if not setup_executor(ssh_runner):
        print("[!] Executor setup failed")
        vm_manager.terminate_vm()
        return 1
    
    # Shutdown VM for clean fuzzing sessions
    print("[*] Setup complete, shutting down for clean sessions...")
    vm_manager.shutdown_vm()
    time.sleep(3)
    
    # Main fuzzing loop
    print("\n" + "#" * 70)
    print(f"{'READY TO FUZZ':^70}")
    print("#" * 70)
    
    try:
        while True:
            # Start fresh VM
            if not vm_manager.start_vm():
                print("[!] Failed to start VM")
                break
            
            # Create fuzzing engine for this session
            fuzzing_engine = FuzzingEngine(ssh_runner, crash_logger)
            
            # Run fuzzing session
            user_interrupted = fuzzing_engine.run_session()
            
            # Print statistics
            fuzzing_engine.print_stats()
            
            # Clean up VM
            if user_interrupted:
                print("[*] User requested shutdown")
                vm_manager.shutdown_vm()
                break
            else:
                print("[*] Crash detected - restarting VM for next session")
                vm_manager.terminate_vm()
                time.sleep(3)
    
    except KeyboardInterrupt:
        print("\n\n[!] Fuzzer interrupted")
    except Exception as e:
        print(f"\n[!] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\n[*] Cleaning up...")
        vm_manager.terminate_vm()
        print("[+] Fuzzer shutdown complete")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())